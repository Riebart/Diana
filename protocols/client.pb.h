// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.proto

#ifndef PROTOBUF_client_2eproto__INCLUDED
#define PROTOBUF_client_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2eproto();
void protobuf_AssignDesc_client_2eproto();
void protobuf_ShutdownFile_client_2eproto();

class MessageWrapper;
class VectorMsg;
class ThrustMsg;
class VelocityMsg;
class JumpMsg;
class InfoMsg;
class RequestMsg;

enum MessageWrapper_MessageType {
  MessageWrapper_MessageType_THRUST = 1,
  MessageWrapper_MessageType_VELOCITY = 2,
  MessageWrapper_MessageType_JUMP = 3,
  MessageWrapper_MessageType_INFO = 4,
  MessageWrapper_MessageType_REQUEST = 5
};
bool MessageWrapper_MessageType_IsValid(int value);
const MessageWrapper_MessageType MessageWrapper_MessageType_MessageType_MIN = MessageWrapper_MessageType_THRUST;
const MessageWrapper_MessageType MessageWrapper_MessageType_MessageType_MAX = MessageWrapper_MessageType_REQUEST;
const int MessageWrapper_MessageType_MessageType_ARRAYSIZE = MessageWrapper_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageWrapper_MessageType_descriptor();
inline const ::std::string& MessageWrapper_MessageType_Name(MessageWrapper_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageWrapper_MessageType_descriptor(), value);
}
inline bool MessageWrapper_MessageType_Parse(
    const ::std::string& name, MessageWrapper_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageWrapper_MessageType>(
    MessageWrapper_MessageType_descriptor(), name, value);
}
// ===================================================================

class MessageWrapper : public ::google::protobuf::Message {
 public:
  MessageWrapper();
  virtual ~MessageWrapper();

  MessageWrapper(const MessageWrapper& from);

  inline MessageWrapper& operator=(const MessageWrapper& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageWrapper& default_instance();

  void Swap(MessageWrapper* other);

  // implements Message ----------------------------------------------

  MessageWrapper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageWrapper& from);
  void MergeFrom(const MessageWrapper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MessageWrapper_MessageType MessageType;
  static const MessageType THRUST = MessageWrapper_MessageType_THRUST;
  static const MessageType VELOCITY = MessageWrapper_MessageType_VELOCITY;
  static const MessageType JUMP = MessageWrapper_MessageType_JUMP;
  static const MessageType INFO = MessageWrapper_MessageType_INFO;
  static const MessageType REQUEST = MessageWrapper_MessageType_REQUEST;
  static inline bool MessageType_IsValid(int value) {
    return MessageWrapper_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    MessageWrapper_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    MessageWrapper_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    MessageWrapper_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return MessageWrapper_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return MessageWrapper_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return MessageWrapper_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .client.MessageWrapper.MessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::client::MessageWrapper_MessageType messagetype() const;
  inline void set_messagetype(::client::MessageWrapper_MessageType value);

  // optional .client.ThrustMsg thrustMsg = 2;
  inline bool has_thrustmsg() const;
  inline void clear_thrustmsg();
  static const int kThrustMsgFieldNumber = 2;
  inline const ::client::ThrustMsg& thrustmsg() const;
  inline ::client::ThrustMsg* mutable_thrustmsg();
  inline ::client::ThrustMsg* release_thrustmsg();
  inline void set_allocated_thrustmsg(::client::ThrustMsg* thrustmsg);

  // optional .client.VelocityMsg velocityMsg = 3;
  inline bool has_velocitymsg() const;
  inline void clear_velocitymsg();
  static const int kVelocityMsgFieldNumber = 3;
  inline const ::client::VelocityMsg& velocitymsg() const;
  inline ::client::VelocityMsg* mutable_velocitymsg();
  inline ::client::VelocityMsg* release_velocitymsg();
  inline void set_allocated_velocitymsg(::client::VelocityMsg* velocitymsg);

  // optional .client.JumpMsg jumpMsg = 4;
  inline bool has_jumpmsg() const;
  inline void clear_jumpmsg();
  static const int kJumpMsgFieldNumber = 4;
  inline const ::client::JumpMsg& jumpmsg() const;
  inline ::client::JumpMsg* mutable_jumpmsg();
  inline ::client::JumpMsg* release_jumpmsg();
  inline void set_allocated_jumpmsg(::client::JumpMsg* jumpmsg);

  // optional .client.InfoMsg infoMsg = 5;
  inline bool has_infomsg() const;
  inline void clear_infomsg();
  static const int kInfoMsgFieldNumber = 5;
  inline const ::client::InfoMsg& infomsg() const;
  inline ::client::InfoMsg* mutable_infomsg();
  inline ::client::InfoMsg* release_infomsg();
  inline void set_allocated_infomsg(::client::InfoMsg* infomsg);

  // optional .client.RequestMsg requestMsg = 6;
  inline bool has_requestmsg() const;
  inline void clear_requestmsg();
  static const int kRequestMsgFieldNumber = 6;
  inline const ::client::RequestMsg& requestmsg() const;
  inline ::client::RequestMsg* mutable_requestmsg();
  inline ::client::RequestMsg* release_requestmsg();
  inline void set_allocated_requestmsg(::client::RequestMsg* requestmsg);

  // @@protoc_insertion_point(class_scope:client.MessageWrapper)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_thrustmsg();
  inline void clear_has_thrustmsg();
  inline void set_has_velocitymsg();
  inline void clear_has_velocitymsg();
  inline void set_has_jumpmsg();
  inline void clear_has_jumpmsg();
  inline void set_has_infomsg();
  inline void clear_has_infomsg();
  inline void set_has_requestmsg();
  inline void clear_has_requestmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::client::ThrustMsg* thrustmsg_;
  ::client::VelocityMsg* velocitymsg_;
  ::client::JumpMsg* jumpmsg_;
  ::client::InfoMsg* infomsg_;
  ::client::RequestMsg* requestmsg_;
  int messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static MessageWrapper* default_instance_;
};
// -------------------------------------------------------------------

class VectorMsg : public ::google::protobuf::Message {
 public:
  VectorMsg();
  virtual ~VectorMsg();

  VectorMsg(const VectorMsg& from);

  inline VectorMsg& operator=(const VectorMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VectorMsg& default_instance();

  void Swap(VectorMsg* other);

  // implements Message ----------------------------------------------

  VectorMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VectorMsg& from);
  void MergeFrom(const VectorMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:client.VectorMsg)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static VectorMsg* default_instance_;
};
// -------------------------------------------------------------------

class ThrustMsg : public ::google::protobuf::Message {
 public:
  ThrustMsg();
  virtual ~ThrustMsg();

  ThrustMsg(const ThrustMsg& from);

  inline ThrustMsg& operator=(const ThrustMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThrustMsg& default_instance();

  void Swap(ThrustMsg* other);

  // implements Message ----------------------------------------------

  ThrustMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThrustMsg& from);
  void MergeFrom(const ThrustMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "THRUST"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .client.VectorMsg thrust = 2;
  inline bool has_thrust() const;
  inline void clear_thrust();
  static const int kThrustFieldNumber = 2;
  inline const ::client::VectorMsg& thrust() const;
  inline ::client::VectorMsg* mutable_thrust();
  inline ::client::VectorMsg* release_thrust();
  inline void set_allocated_thrust(::client::VectorMsg* thrust);

  // @@protoc_insertion_point(class_scope:client.ThrustMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_thrust();
  inline void clear_has_thrust();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::client::VectorMsg* thrust_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static ThrustMsg* default_instance_;
};
// -------------------------------------------------------------------

class VelocityMsg : public ::google::protobuf::Message {
 public:
  VelocityMsg();
  virtual ~VelocityMsg();

  VelocityMsg(const VelocityMsg& from);

  inline VelocityMsg& operator=(const VelocityMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VelocityMsg& default_instance();

  void Swap(VelocityMsg* other);

  // implements Message ----------------------------------------------

  VelocityMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VelocityMsg& from);
  void MergeFrom(const VelocityMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "VELOCITY"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .client.VectorMsg velocity = 2;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  inline const ::client::VectorMsg& velocity() const;
  inline ::client::VectorMsg* mutable_velocity();
  inline ::client::VectorMsg* release_velocity();
  inline void set_allocated_velocity(::client::VectorMsg* velocity);

  // @@protoc_insertion_point(class_scope:client.VelocityMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_velocity();
  inline void clear_has_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::client::VectorMsg* velocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static VelocityMsg* default_instance_;
};
// -------------------------------------------------------------------

class JumpMsg : public ::google::protobuf::Message {
 public:
  JumpMsg();
  virtual ~JumpMsg();

  JumpMsg(const JumpMsg& from);

  inline JumpMsg& operator=(const JumpMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JumpMsg& default_instance();

  void Swap(JumpMsg* other);

  // implements Message ----------------------------------------------

  JumpMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JumpMsg& from);
  void MergeFrom(const JumpMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "JUMP"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .client.VectorMsg new_position = 2;
  inline bool has_new_position() const;
  inline void clear_new_position();
  static const int kNewPositionFieldNumber = 2;
  inline const ::client::VectorMsg& new_position() const;
  inline ::client::VectorMsg* mutable_new_position();
  inline ::client::VectorMsg* release_new_position();
  inline void set_allocated_new_position(::client::VectorMsg* new_position);

  // @@protoc_insertion_point(class_scope:client.JumpMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_new_position();
  inline void clear_has_new_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::client::VectorMsg* new_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static JumpMsg* default_instance_;
};
// -------------------------------------------------------------------

class InfoMsg : public ::google::protobuf::Message {
 public:
  InfoMsg();
  virtual ~InfoMsg();

  InfoMsg(const InfoMsg& from);

  inline InfoMsg& operator=(const InfoMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoMsg& default_instance();

  void Swap(InfoMsg* other);

  // implements Message ----------------------------------------------

  InfoMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfoMsg& from);
  void MergeFrom(const InfoMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "INFO"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string infoType = 2;
  inline bool has_infotype() const;
  inline void clear_infotype();
  static const int kInfoTypeFieldNumber = 2;
  inline const ::std::string& infotype() const;
  inline void set_infotype(const ::std::string& value);
  inline void set_infotype(const char* value);
  inline void set_infotype(const char* value, size_t size);
  inline ::std::string* mutable_infotype();
  inline ::std::string* release_infotype();
  inline void set_allocated_infotype(::std::string* infotype);

  // required string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:client.InfoMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_infotype();
  inline void clear_has_infotype();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* infotype_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static InfoMsg* default_instance_;
};
// -------------------------------------------------------------------

class RequestMsg : public ::google::protobuf::Message {
 public:
  RequestMsg();
  virtual ~RequestMsg();

  RequestMsg(const RequestMsg& from);

  inline RequestMsg& operator=(const RequestMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMsg& default_instance();

  void Swap(RequestMsg* other);

  // implements Message ----------------------------------------------

  RequestMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestMsg& from);
  void MergeFrom(const RequestMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "REQUEST"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 continuous = 2;
  inline bool has_continuous() const;
  inline void clear_continuous();
  static const int kContinuousFieldNumber = 2;
  inline ::google::protobuf::int32 continuous() const;
  inline void set_continuous(::google::protobuf::int32 value);

  // required string requestType = 3;
  inline bool has_requesttype() const;
  inline void clear_requesttype();
  static const int kRequestTypeFieldNumber = 3;
  inline const ::std::string& requesttype() const;
  inline void set_requesttype(const ::std::string& value);
  inline void set_requesttype(const char* value);
  inline void set_requesttype(const char* value, size_t size);
  inline ::std::string* mutable_requesttype();
  inline ::std::string* release_requesttype();
  inline void set_allocated_requesttype(::std::string* requesttype);

  // @@protoc_insertion_point(class_scope:client.RequestMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_continuous();
  inline void clear_has_continuous();
  inline void set_has_requesttype();
  inline void clear_has_requesttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* requesttype_;
  ::google::protobuf::int32 continuous_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static RequestMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageWrapper

// required .client.MessageWrapper.MessageType messageType = 1;
inline bool MessageWrapper::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageWrapper::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageWrapper::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageWrapper::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::client::MessageWrapper_MessageType MessageWrapper::messagetype() const {
  return static_cast< ::client::MessageWrapper_MessageType >(messagetype_);
}
inline void MessageWrapper::set_messagetype(::client::MessageWrapper_MessageType value) {
  assert(::client::MessageWrapper_MessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// optional .client.ThrustMsg thrustMsg = 2;
inline bool MessageWrapper::has_thrustmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageWrapper::set_has_thrustmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageWrapper::clear_has_thrustmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageWrapper::clear_thrustmsg() {
  if (thrustmsg_ != NULL) thrustmsg_->::client::ThrustMsg::Clear();
  clear_has_thrustmsg();
}
inline const ::client::ThrustMsg& MessageWrapper::thrustmsg() const {
  return thrustmsg_ != NULL ? *thrustmsg_ : *default_instance_->thrustmsg_;
}
inline ::client::ThrustMsg* MessageWrapper::mutable_thrustmsg() {
  set_has_thrustmsg();
  if (thrustmsg_ == NULL) thrustmsg_ = new ::client::ThrustMsg;
  return thrustmsg_;
}
inline ::client::ThrustMsg* MessageWrapper::release_thrustmsg() {
  clear_has_thrustmsg();
  ::client::ThrustMsg* temp = thrustmsg_;
  thrustmsg_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_thrustmsg(::client::ThrustMsg* thrustmsg) {
  delete thrustmsg_;
  thrustmsg_ = thrustmsg;
  if (thrustmsg) {
    set_has_thrustmsg();
  } else {
    clear_has_thrustmsg();
  }
}

// optional .client.VelocityMsg velocityMsg = 3;
inline bool MessageWrapper::has_velocitymsg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageWrapper::set_has_velocitymsg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageWrapper::clear_has_velocitymsg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageWrapper::clear_velocitymsg() {
  if (velocitymsg_ != NULL) velocitymsg_->::client::VelocityMsg::Clear();
  clear_has_velocitymsg();
}
inline const ::client::VelocityMsg& MessageWrapper::velocitymsg() const {
  return velocitymsg_ != NULL ? *velocitymsg_ : *default_instance_->velocitymsg_;
}
inline ::client::VelocityMsg* MessageWrapper::mutable_velocitymsg() {
  set_has_velocitymsg();
  if (velocitymsg_ == NULL) velocitymsg_ = new ::client::VelocityMsg;
  return velocitymsg_;
}
inline ::client::VelocityMsg* MessageWrapper::release_velocitymsg() {
  clear_has_velocitymsg();
  ::client::VelocityMsg* temp = velocitymsg_;
  velocitymsg_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_velocitymsg(::client::VelocityMsg* velocitymsg) {
  delete velocitymsg_;
  velocitymsg_ = velocitymsg;
  if (velocitymsg) {
    set_has_velocitymsg();
  } else {
    clear_has_velocitymsg();
  }
}

// optional .client.JumpMsg jumpMsg = 4;
inline bool MessageWrapper::has_jumpmsg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageWrapper::set_has_jumpmsg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageWrapper::clear_has_jumpmsg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageWrapper::clear_jumpmsg() {
  if (jumpmsg_ != NULL) jumpmsg_->::client::JumpMsg::Clear();
  clear_has_jumpmsg();
}
inline const ::client::JumpMsg& MessageWrapper::jumpmsg() const {
  return jumpmsg_ != NULL ? *jumpmsg_ : *default_instance_->jumpmsg_;
}
inline ::client::JumpMsg* MessageWrapper::mutable_jumpmsg() {
  set_has_jumpmsg();
  if (jumpmsg_ == NULL) jumpmsg_ = new ::client::JumpMsg;
  return jumpmsg_;
}
inline ::client::JumpMsg* MessageWrapper::release_jumpmsg() {
  clear_has_jumpmsg();
  ::client::JumpMsg* temp = jumpmsg_;
  jumpmsg_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_jumpmsg(::client::JumpMsg* jumpmsg) {
  delete jumpmsg_;
  jumpmsg_ = jumpmsg;
  if (jumpmsg) {
    set_has_jumpmsg();
  } else {
    clear_has_jumpmsg();
  }
}

// optional .client.InfoMsg infoMsg = 5;
inline bool MessageWrapper::has_infomsg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageWrapper::set_has_infomsg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageWrapper::clear_has_infomsg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageWrapper::clear_infomsg() {
  if (infomsg_ != NULL) infomsg_->::client::InfoMsg::Clear();
  clear_has_infomsg();
}
inline const ::client::InfoMsg& MessageWrapper::infomsg() const {
  return infomsg_ != NULL ? *infomsg_ : *default_instance_->infomsg_;
}
inline ::client::InfoMsg* MessageWrapper::mutable_infomsg() {
  set_has_infomsg();
  if (infomsg_ == NULL) infomsg_ = new ::client::InfoMsg;
  return infomsg_;
}
inline ::client::InfoMsg* MessageWrapper::release_infomsg() {
  clear_has_infomsg();
  ::client::InfoMsg* temp = infomsg_;
  infomsg_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_infomsg(::client::InfoMsg* infomsg) {
  delete infomsg_;
  infomsg_ = infomsg;
  if (infomsg) {
    set_has_infomsg();
  } else {
    clear_has_infomsg();
  }
}

// optional .client.RequestMsg requestMsg = 6;
inline bool MessageWrapper::has_requestmsg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageWrapper::set_has_requestmsg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageWrapper::clear_has_requestmsg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageWrapper::clear_requestmsg() {
  if (requestmsg_ != NULL) requestmsg_->::client::RequestMsg::Clear();
  clear_has_requestmsg();
}
inline const ::client::RequestMsg& MessageWrapper::requestmsg() const {
  return requestmsg_ != NULL ? *requestmsg_ : *default_instance_->requestmsg_;
}
inline ::client::RequestMsg* MessageWrapper::mutable_requestmsg() {
  set_has_requestmsg();
  if (requestmsg_ == NULL) requestmsg_ = new ::client::RequestMsg;
  return requestmsg_;
}
inline ::client::RequestMsg* MessageWrapper::release_requestmsg() {
  clear_has_requestmsg();
  ::client::RequestMsg* temp = requestmsg_;
  requestmsg_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_requestmsg(::client::RequestMsg* requestmsg) {
  delete requestmsg_;
  requestmsg_ = requestmsg;
  if (requestmsg) {
    set_has_requestmsg();
  } else {
    clear_has_requestmsg();
  }
}

// -------------------------------------------------------------------

// VectorMsg

// required double x = 1;
inline bool VectorMsg::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VectorMsg::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VectorMsg::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VectorMsg::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double VectorMsg::x() const {
  return x_;
}
inline void VectorMsg::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool VectorMsg::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VectorMsg::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VectorMsg::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VectorMsg::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double VectorMsg::y() const {
  return y_;
}
inline void VectorMsg::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool VectorMsg::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VectorMsg::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VectorMsg::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VectorMsg::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double VectorMsg::z() const {
  return z_;
}
inline void VectorMsg::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// ThrustMsg

// optional string name = 1 [default = "THRUST"];
inline bool ThrustMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThrustMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThrustMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThrustMsg::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& ThrustMsg::name() const {
  return *name_;
}
inline void ThrustMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ThrustMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ThrustMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThrustMsg::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* ThrustMsg::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void ThrustMsg::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required .client.VectorMsg thrust = 2;
inline bool ThrustMsg::has_thrust() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThrustMsg::set_has_thrust() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThrustMsg::clear_has_thrust() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThrustMsg::clear_thrust() {
  if (thrust_ != NULL) thrust_->::client::VectorMsg::Clear();
  clear_has_thrust();
}
inline const ::client::VectorMsg& ThrustMsg::thrust() const {
  return thrust_ != NULL ? *thrust_ : *default_instance_->thrust_;
}
inline ::client::VectorMsg* ThrustMsg::mutable_thrust() {
  set_has_thrust();
  if (thrust_ == NULL) thrust_ = new ::client::VectorMsg;
  return thrust_;
}
inline ::client::VectorMsg* ThrustMsg::release_thrust() {
  clear_has_thrust();
  ::client::VectorMsg* temp = thrust_;
  thrust_ = NULL;
  return temp;
}
inline void ThrustMsg::set_allocated_thrust(::client::VectorMsg* thrust) {
  delete thrust_;
  thrust_ = thrust;
  if (thrust) {
    set_has_thrust();
  } else {
    clear_has_thrust();
  }
}

// -------------------------------------------------------------------

// VelocityMsg

// optional string name = 1 [default = "VELOCITY"];
inline bool VelocityMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VelocityMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VelocityMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VelocityMsg::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& VelocityMsg::name() const {
  return *name_;
}
inline void VelocityMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VelocityMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VelocityMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VelocityMsg::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* VelocityMsg::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void VelocityMsg::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required .client.VectorMsg velocity = 2;
inline bool VelocityMsg::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VelocityMsg::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VelocityMsg::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VelocityMsg::clear_velocity() {
  if (velocity_ != NULL) velocity_->::client::VectorMsg::Clear();
  clear_has_velocity();
}
inline const ::client::VectorMsg& VelocityMsg::velocity() const {
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::client::VectorMsg* VelocityMsg::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::client::VectorMsg;
  return velocity_;
}
inline ::client::VectorMsg* VelocityMsg::release_velocity() {
  clear_has_velocity();
  ::client::VectorMsg* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void VelocityMsg::set_allocated_velocity(::client::VectorMsg* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
}

// -------------------------------------------------------------------

// JumpMsg

// optional string name = 1 [default = "JUMP"];
inline bool JumpMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JumpMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JumpMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JumpMsg::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& JumpMsg::name() const {
  return *name_;
}
inline void JumpMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JumpMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JumpMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JumpMsg::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* JumpMsg::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void JumpMsg::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required .client.VectorMsg new_position = 2;
inline bool JumpMsg::has_new_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JumpMsg::set_has_new_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JumpMsg::clear_has_new_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JumpMsg::clear_new_position() {
  if (new_position_ != NULL) new_position_->::client::VectorMsg::Clear();
  clear_has_new_position();
}
inline const ::client::VectorMsg& JumpMsg::new_position() const {
  return new_position_ != NULL ? *new_position_ : *default_instance_->new_position_;
}
inline ::client::VectorMsg* JumpMsg::mutable_new_position() {
  set_has_new_position();
  if (new_position_ == NULL) new_position_ = new ::client::VectorMsg;
  return new_position_;
}
inline ::client::VectorMsg* JumpMsg::release_new_position() {
  clear_has_new_position();
  ::client::VectorMsg* temp = new_position_;
  new_position_ = NULL;
  return temp;
}
inline void JumpMsg::set_allocated_new_position(::client::VectorMsg* new_position) {
  delete new_position_;
  new_position_ = new_position;
  if (new_position) {
    set_has_new_position();
  } else {
    clear_has_new_position();
  }
}

// -------------------------------------------------------------------

// InfoMsg

// optional string name = 1 [default = "INFO"];
inline bool InfoMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoMsg::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& InfoMsg::name() const {
  return *name_;
}
inline void InfoMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InfoMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InfoMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoMsg::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* InfoMsg::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void InfoMsg::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required string infoType = 2;
inline bool InfoMsg::has_infotype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoMsg::set_has_infotype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfoMsg::clear_has_infotype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfoMsg::clear_infotype() {
  if (infotype_ != &::google::protobuf::internal::kEmptyString) {
    infotype_->clear();
  }
  clear_has_infotype();
}
inline const ::std::string& InfoMsg::infotype() const {
  return *infotype_;
}
inline void InfoMsg::set_infotype(const ::std::string& value) {
  set_has_infotype();
  if (infotype_ == &::google::protobuf::internal::kEmptyString) {
    infotype_ = new ::std::string;
  }
  infotype_->assign(value);
}
inline void InfoMsg::set_infotype(const char* value) {
  set_has_infotype();
  if (infotype_ == &::google::protobuf::internal::kEmptyString) {
    infotype_ = new ::std::string;
  }
  infotype_->assign(value);
}
inline void InfoMsg::set_infotype(const char* value, size_t size) {
  set_has_infotype();
  if (infotype_ == &::google::protobuf::internal::kEmptyString) {
    infotype_ = new ::std::string;
  }
  infotype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoMsg::mutable_infotype() {
  set_has_infotype();
  if (infotype_ == &::google::protobuf::internal::kEmptyString) {
    infotype_ = new ::std::string;
  }
  return infotype_;
}
inline ::std::string* InfoMsg::release_infotype() {
  clear_has_infotype();
  if (infotype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = infotype_;
    infotype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InfoMsg::set_allocated_infotype(::std::string* infotype) {
  if (infotype_ != &::google::protobuf::internal::kEmptyString) {
    delete infotype_;
  }
  if (infotype) {
    set_has_infotype();
    infotype_ = infotype;
  } else {
    clear_has_infotype();
    infotype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string data = 3;
inline bool InfoMsg::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InfoMsg::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InfoMsg::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InfoMsg::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& InfoMsg::data() const {
  return *data_;
}
inline void InfoMsg::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void InfoMsg::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void InfoMsg::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoMsg::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* InfoMsg::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InfoMsg::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestMsg

// optional string name = 1 [default = "REQUEST"];
inline bool RequestMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestMsg::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& RequestMsg::name() const {
  return *name_;
}
inline void RequestMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestMsg::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* RequestMsg::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void RequestMsg::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required int32 continuous = 2;
inline bool RequestMsg::has_continuous() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestMsg::set_has_continuous() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestMsg::clear_has_continuous() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestMsg::clear_continuous() {
  continuous_ = 0;
  clear_has_continuous();
}
inline ::google::protobuf::int32 RequestMsg::continuous() const {
  return continuous_;
}
inline void RequestMsg::set_continuous(::google::protobuf::int32 value) {
  set_has_continuous();
  continuous_ = value;
}

// required string requestType = 3;
inline bool RequestMsg::has_requesttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestMsg::set_has_requesttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestMsg::clear_has_requesttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestMsg::clear_requesttype() {
  if (requesttype_ != &::google::protobuf::internal::kEmptyString) {
    requesttype_->clear();
  }
  clear_has_requesttype();
}
inline const ::std::string& RequestMsg::requesttype() const {
  return *requesttype_;
}
inline void RequestMsg::set_requesttype(const ::std::string& value) {
  set_has_requesttype();
  if (requesttype_ == &::google::protobuf::internal::kEmptyString) {
    requesttype_ = new ::std::string;
  }
  requesttype_->assign(value);
}
inline void RequestMsg::set_requesttype(const char* value) {
  set_has_requesttype();
  if (requesttype_ == &::google::protobuf::internal::kEmptyString) {
    requesttype_ = new ::std::string;
  }
  requesttype_->assign(value);
}
inline void RequestMsg::set_requesttype(const char* value, size_t size) {
  set_has_requesttype();
  if (requesttype_ == &::google::protobuf::internal::kEmptyString) {
    requesttype_ = new ::std::string;
  }
  requesttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestMsg::mutable_requesttype() {
  set_has_requesttype();
  if (requesttype_ == &::google::protobuf::internal::kEmptyString) {
    requesttype_ = new ::std::string;
  }
  return requesttype_;
}
inline ::std::string* RequestMsg::release_requesttype() {
  clear_has_requesttype();
  if (requesttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requesttype_;
    requesttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestMsg::set_allocated_requesttype(::std::string* requesttype) {
  if (requesttype_ != &::google::protobuf::internal::kEmptyString) {
    delete requesttype_;
  }
  if (requesttype) {
    set_has_requesttype();
    requesttype_ = requesttype;
  } else {
    clear_has_requesttype();
    requesttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client::MessageWrapper_MessageType>() {
  return ::client::MessageWrapper_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2eproto__INCLUDED
